Architectural
 
Mastery
 
of
 
the
 
Garmin
 
Health
 
API:
 
A
 
Comprehensive
 
Integration
 
Report
 
1.
 
The
 
Strategic
 
Landscape
 
of
 
Wearable
 
Health
 
Integration
 
The
 
integration
 
of
 
wearable
 
biometric
 
data
 
into
 
enterprise
 
health
 
platforms
 
represents
 
a
 
shift
 
from
 
simple
 
activity
 
tracking
 
to
 
clinical-grade
 
remote
 
patient
 
monitoring
 
(RPM)
 
and
 
sophisticated
 
corporate
 
wellness
 
solutions.
 
Within
 
this
 
ecosystem,
 
Garmin
 
occupies
 
a
 
unique
 
position.
 
Unlike
 
consumer-grade
 
counterparts
 
that
 
prioritize
 
ecosystem
 
lock-in
 
or
 
social
 
features,
 
Garmin’s
 
architecture—rooted
 
in
 
aviation
 
and
 
marine
 
navigation—prioritizes
 
sensor
 
accuracy,
 
battery
 
longevity,
 
and
 
data
 
fidelity.
 
For
 
the
 
systems
 
architect
 
or
 
lead
 
engineer,
 
the
 
Garmin
 
Health
 
API
 
is
 
not
 
merely
 
a
 
data
 
pipe;
 
it
 
is
 
a
 
gateway
 
to
 
longitudinal
 
physiological
 
datasets
 
that
 
can
 
drive
 
predictive
 
health
 
analytics.
 
Integrating
 
with
 
Garmin
 
requires
 
navigating
 
a
 
governed
 
ecosystem.
 
Unlike
 
open
 
APIs
 
that
 
allow
 
unrestricted
 
public
 
access,
 
the
 
Garmin
 
Connect
 
Developer
 
Program
 
operates
 
on
 
a
 
permissioned
 
model,
 
distinguishing
 
between
 
"Evaluation"
 
(sandbox)
 
and
 
"Production"
 
(commercial)
 
environments.
 
This
 
distinction
 
governs
 
everything
 
from
 
rate
 
limits
 
to
 
data
 
granularity.
 
Furthermore,
 
the
 
architecture
 
is
 
fundamentally
 
event-driven
.
 
Rather
 
than
 
supporting
 
high-frequency
 
client
 
polling—which
 
wastes
 
bandwidth
 
and
 
battery—Garmin
 
forces
 
a
 
synchronization-based
 
paradigm.
 
Data
 
flows
 
from
 
the
 
device
 
to
 
Garmin’s
 
cloud,
 
processed
 
asynchronously,
 
and
 
is
 
then
 
pushed
 
to
 
partner
 
webhooks.
 
This
 
report
 
dissects
 
these
 
mechanisms,
 
providing
 
the
 
technical
 
depth
 
required
 
to
 
build
 
scalable,
 
fault-tolerant
 
integrations.
1
 
1.1
 
The
 
Ecosystem
 
Triad:
 
Health
 
API,
 
Activity
 
API,
 
and
 
SDKs
 
Before
 
writing
 
code,
 
it
 
is
 
critical
 
to
 
select
 
the
 
correct
 
integration
 
surface.
 
The
 
Garmin
 
Developer
 
Program
 
offers
 
three
 
distinct
 
pathways,
 
often
 
confused
 
by
 
new
 
integrators:
 
1.
 
Health
 
API:
 
The
 
focus
 
of
 
this
 
report.
 
It
 
provides
 
24/7
 
wellness
 
data
 
(steps,
 
sleep,
 
HRV,
 
stress,
 
body
 
battery)
 
synced
 
via
 
the
 
Garmin
 
Connect
 
cloud.
 
It
 
is
 
a
 
RESTful
 
service
 
ideal
 
for
 
web
 
and
 
mobile
 
dashboards
 
that
 
do
 
not
 
require
 
real-time
 
(second-by-second)
 
streaming
 
from
 
the
 
device.
1
 
2.
 
Activity
 
API:
 
Often
 
used
 
in
 
tandem
 
with
 
the
 
Health
 
API,
 
this
 
provides
 
detailed
 
files
 
(FIT
 
format)
 
for
 
timed
 
workouts
 
(runs,
 
swims,
 
cycles).
 
While
 
the
 
Health
 
API
 
provides
 
a
 
summary
 
of
 
these
 
events,
 
the
 
Activity
 
API
 
provides
 
the
 
GPS
 
traces
 
and
 
sensor
 
streams.
4
 
3.
 
Standard/Companion
 
SDKs:
 
These
 
allow
 
a
 
mobile
 
app
 
to
 
communicate
 
directly
 
with
 
the
 

---PAGE---

watch
 
via
 
Bluetooth,
 
bypassing
 
the
 
Garmin
 
cloud.
 
This
 
is
 
required
 
for
 
real-time
 
applications
 
(e.g.,
 
a
 
boxing
 
app
 
showing
 
live
 
heart
 
rate)
 
but
 
is
 
architecturally
 
distinct
 
from
 
the
 
cloud-based
 
Health
 
API.
3
 
This
 
analysis
 
focuses
 
on
 
the
 
Cloud-to-Cloud
 
Health
 
API
 
integration,
 
the
 
industry
 
standard
 
for
 
population
 
health
 
management
 
and
 
insurance
 
telemetry.
 
2.
 
Security
 
Protocol:
 
OAuth
 
2.0
 
and
 
Identity
 
Management
 
Security
 
in
 
health
 
data
 
integration
 
is
 
non-negotiable.
 
Garmin
 
has
 
migrated
 
its
 
authentication
 
standard
 
from
 
the
 
legacy
 
OAuth
 
1.0a
 
(referenced
 
in
 
older
 
documentation)
 
to
 
OAuth
 
2.0
 
with
 
Proof
 
of
 
Key
 
Code
 
Exchange
 
(PKCE)
.
 
This
 
protocol
 
is
 
mandatory
 
for
 
all
 
new
 
integrations,
 
addressing
 
specific
 
vulnerabilities
 
in
 
public
 
clients
 
(like
 
mobile
 
apps)
 
where
 
storing
 
a
 
client
 
secret
 
is
 
insecure.
5
 
2.1
 
The
 
OAuth
 
2.0
 
PKCE
 
Authorization
 
Flow
 
The
 
PKCE
 
(pronounced
 
"pixy")
 
extension
 
prevents
 
authorization
 
code
 
interception
 
attacks.
 
In
 
a
 
standard
 
OAuth
 
exchange,
 
if
 
a
 
malicious
 
app
 
intercepts
 
the
 
authorization
 
code
 
returned
 
by
 
Garmin,
 
it
 
could
 
potentially
 
exchange
 
it
 
for
 
an
 
access
 
token.
 
PKCE
 
mitigates
 
this
 
by
 
requiring
 
a
 
dynamic
 
"secret"
 
generated
 
for
 
each
 
session.
 
The
 
Cryptographic
 
Sequence:
 
1.
 
Code
 
Verifier
 
($v$):
 
The
 
client
 
generates
 
a
 
high-entropy
 
random
 
string
 
between
 
43
 
and
 
128
 
characters,
 
using
 
unreserved
 
characters
 
[A-Z,
 
a-z,
 
0-9,
 
-,.,
 
_,
 
~].
 
This
 
serves
 
as
 
the
 
dynamic
 
secret.
 
2.
 
Code
 
Challenge
 
($c$):
 
The
 
client
 
derives
 
a
 
challenge
 
from
 
the
 
verifier
 
using
 
a
 
SHA-256
 
hash
 
and
 
Base64URL
 
encoding.
 
 
$$c
 
=
 
\text{Base64URL}(\text{SHA256}(v))$$
 
 
Garmin
 
mandates
 
the
 
S256
 
transformation
 
method.5
 
3.
 
Initial
 
Request:
 
The
 
client
 
redirects
 
the
 
user
 
to
 
https://connect.garmin.com/oauthConfirm.
 
The
 
query
 
parameters
 
must
 
include
 
client_id,
 
redirect_uri,
 
response_type=code,
 
and
 
crucially,
 
the
 
code_challenge
 
($c$)
 
and
 
code_challenge_method=S256.
 
4.
 
Authorization:
 
The
 
user
 
authenticates
 
and
 
grants
 
scope
 
permissions.
 
Garmin
 
stores
 
the
 
code_challenge
 
temporarily.
 
5.
 
Callback:
 
Garmin
 
redirects
 
to
 
the
 
partner's
 
redirect_uri
 
with
 
an
 
authorization_code.
 
6.
 
Token
 
Exchange:
 
The
 
client
 
sends
 
a
 
POST
 
request
 
to
 

---PAGE---

https://diauth.garmin.com/di-oauth2-service/oauth/token.
 
This
 
request
 
includes
 
the
 
authorization_code
 
and
 
the
 
original
 
plaintext
 
code_verifier
 
($v$).
 
7.
 
Validation:
 
Garmin's
 
server
 
calculates
 
$\text{Base64URL}(\text{SHA256}(v))$
 
and
 
compares
 
it
 
to
 
the
 
stored
 
code_challenge
 
($c$).
 
If
 
they
 
match,
 
it
 
proves
 
the
 
entity
 
exchanging
 
the
 
code
 
is
 
the
 
same
 
entity
 
that
 
initiated
 
the
 
request,
 
issuing
 
the
 
access_token
 
and
 
refresh_token.
5
 
2.2
 
Token
 
Lifecycle
 
and
 
Rotation
 
Policies
 
Handling
 
Garmin
 
tokens
 
requires
 
strict
 
adherence
 
to
 
their
 
rotation
 
policy
 
to
 
prevent
 
user
 
disconnection
 
(a
 
"dead
 
end"
 
state
 
requiring
 
manual
 
re-authentication).
 
●
 
Access
 
Token:
 
This
 
is
 
a
 
Bearer
 
token
 
used
 
in
 
the
 
HTTP
 
Authorization
 
header.
 
It
 
has
 
a
 
short
 
Time-To-Live
 
(TTL),
 
typically
 
expiring
 
significantly
 
faster
 
than
 
the
 
refresh
 
token
 
to
 
minimize
 
the
 
window
 
of
 
opportunity
 
for
 
token
 
theft.
 
●
 
Refresh
 
Token:
 
This
 
token
 
is
 
used
 
to
 
acquire
 
new
 
access
 
tokens.
 
Crucially,
 
Garmin
 
rotates
 
the
 
refresh
 
token
 
upon
 
use.
 
When
 
an
 
application
 
makes
 
a
 
request
 
to
 
refresh
 
the
 
access
 
token,
 
the
 
response
 
contains
 
a
 
new
 
access
 
token
 
AND
 
a
 
new
 
refresh
 
token.
 
The
 
old
 
refresh
 
token
 
is
 
immediately
 
invalidated.
 
○
 
Operational
 
Risk:
 
If
 
the
 
database
 
update
 
fails
 
after
 
receiving
 
the
 
new
 
refresh
 
token
 
(e.g.,
 
a
 
race
 
condition
 
or
 
crash),
 
the
 
link
 
to
 
the
 
user
 
is
 
lost.
 
Developers
 
must
 
implement
 
atomic
 
transactions
 
when
 
rotating
 
tokens.
5
 
2.3
 
User
 
ID
 
Persistence
 
and
 
Mapping
 
Upon
 
successful
 
authentication,
 
the
 
API
 
returns
 
a
 
userId
 
(often
 
referred
 
to
 
as
 
the
 
generic
 
user
 
key).
 
This
 
ID
 
is
 
unique
 
to
 
the
 
user
 
within
 
the
 
Garmin
 
ecosystem
 
and
 
persists
 
across
 
multiple
 
OAuth
 
consent
 
sessions.
 
If
 
a
 
user
 
revokes
 
access
 
and
 
re-authorizes
 
months
 
later,
 
the
 
access_token
 
will
 
change,
 
but
 
the
 
userId
 
remains
 
constant.
 
This
 
persistence
 
is
 
vital
 
for
 
longitudinal
 
studies
 
where
 
data
 
continuity
 
must
 
be
 
maintained
 
despite
 
authorization
 
interruptions.
5
 
Table
 
1:
 
Security
 
Artifacts
 
and
 
Lifecycles
 
Artifact
 
Role
 
Lifecycle
 
Storage
 
Requirement
 
Client
 
Key
 
Identifies
 
the
 
Partner
 
Permanent
 
Environment
 
Variable
 
/
 
Vault
 
Client
 
Secret
 
Signs
 
Requests
 
Permanent
 
Environment
 
Variable
 
/
 
Vault
 
(Never
 
on
 
Client)
 

---PAGE---

User
 
Access
 
Token
 
API
 
Authorization
 
Short-lived
 
(<
 
24
 
hrs)
 
Encrypted
 
Database
 
Column
 
User
 
Refresh
 
Token
 
Session
 
Renewal
 
Long-lived
 
(Rotates
 
on
 
Use)
 
Encrypted
 
Database
 
Column
 
User
 
ID
 
Data
 
Mapping
 
Permanent
 
Foreign
 
Key
 
in
 
User
 
Table
 
3.
 
Integration
 
Architectures:
 
The
 
Push/Ping
 
Paradigm
 
Garmin’s
 
architecture
 
explicitly
 
discourages
 
polling.
 
High-frequency
 
GET
 
requests
 
to
 
check
 
for
 
new
 
data
 
are
 
inefficient
 
given
 
that
 
data
 
availability
 
is
 
tied
 
to
 
the
 
physical
 
synchronization
 
of
 
the
 
device.
 
Instead,
 
Garmin
 
offers
 
two
 
asynchronous
 
integration
 
patterns:
 
Ping/Pull
 
and
 
Push
.
1
 
3.1
 
The
 
Ping/Pull
 
Architecture
 
In
 
this
 
model,
 
Garmin
 
acts
 
as
 
a
 
notifier.
 
When
 
a
 
user
 
syncs
 
their
 
device,
 
the
 
Garmin
 
Health
 
API
 
processes
 
the
 
data
 
and
 
sends
 
a
 
lightweight
 
notification
 
(the
 
"Ping")
 
to
 
a
 
partner-configured
 
webhook
 
URL.
 
●
 
Mechanism:
 
The
 
Ping
 
is
 
a
 
POST
 
request
 
containing
 
a
 
JSON
 
array
 
of
 
updates.
 
It
 
typically
 
includes
 
the
 
userId,
 
the
 
data
 
type
 
(e.g.,
 
dailies,
 
epochs),
 
and
 
a
 
time
 
range
 
or
 
summary
 
ID.
 
●
 
Action:
 
The
 
partner
 
server
 
acknowledges
 
the
 
Ping
 
(HTTP
 
200)
 
and
 
then
 
queues
 
a
 
job
 
to
 
"Pull"
 
(GET)
 
the
 
actual
 
data
 
from
 
the
 
endpoint
 
specified
 
in
 
the
 
Ping.
 
●
 
Pros:
 
This
 
gives
 
the
 
partner
 
control
 
over
 
ingress
 
traffic.
 
During
 
peak
 
sync
 
times
 
(e.g.,
 
Monday
 
mornings),
 
the
 
partner
 
can
 
queue
 
Pings
 
and
 
fetch
 
data
 
at
 
a
 
rate
 
their
 
database
 
can
 
handle,
 
preventing
 
a
 
Distributed
 
Denial
 
of
 
Service
 
(DDoS)
 
effect.
 
●
 
Cons:
 
Higher
 
latency
 
due
 
to
 
the
 
round-trip
 
(Ping
 
->
 
Ack
 
->
 
Get
 
->
 
Data).
 
3.2
 
The
 
Push
 
Architecture
 
In
 
the
 
Push
 
model,
 
Garmin
 
delivers
 
the
 
full
 
data
 
payload
 
immediately
 
within
 
the
 
POST
 
request.
 
●
 
Mechanism:
 
The
 
webhook
 
receives
 
the
 
complete
 
JSON
 
representation
 
of
 
the
 
daily,
 
epoch,
 
or
 
sleep
 
summary.
 
●
 
Pros:
 
Lowest
 
possible
 
latency.
 
Data
 
is
 
available
 
to
 
the
 
partner
 
seconds
 
after
 
Garmin
 
processes
 
it.
 
Simplifies
 
code
 
by
 
removing
 
the
 
"fetch"
 
logic.
 
●
 
Cons:
 
The
 
partner
 
infrastructure
 
must
 
be
 
robust
 
enough
 
to
 
handle
 
massive
 
concurrent
 
payloads.
 
If
 
10,000
 
users
 
finish
 
a
 
marathon
 
and
 
sync
 
simultaneously,
 
the
 
ingestion
 
endpoint
 
will
 
receive
 
10,000
 
large
 
JSON
 
payloads
 
instantly.
7
 

---PAGE---

3.3
 
Retry
 
Logic
 
and
 
The
 
"On
 
Hold"
 
State
 
Reliability
 
is
 
enforced
 
through
 
a
 
strict
 
retry
 
policy.
 
If
 
the
 
partner's
 
webhook
 
returns
 
a
 
non-200
 
status
 
code
 
(e.g.,
 
500
 
Internal
 
Server
 
Error
 
or
 
503
 
Service
 
Unavailable)
 
or
 
times
 
out:
 
1.
 
Garmin
 
will
 
retry
 
the
 
delivery
 
with
 
an
 
exponential
 
backoff
 
strategy
 
(e.g.,
 
5
 
minutes,
 
15
 
minutes,
 
1
 
hour).
 
2.
 
If
 
failures
 
persist
 
for
 
a
 
defined
 
threshold
 
(typically
 
24-48
 
hours),
 
the
 
specific
 
user
 
subscription
 
is
 
placed
 
in
 
an
 
"On
 
Hold"
 
state.
 
3.
 
Once
 
"On
 
Hold,"
 
Garmin
 
ceases
 
to
 
send
 
notifications
 
for
 
that
 
user
 
to
 
protect
 
its
 
own
 
outbound
 
queues.
 
4.
 
Recovery:
 
The
 
partner
 
must
 
fix
 
their
 
endpoint
 
and
 
then
 
programmatically
 
call
 
the
 
API
 
to
 
remove
 
the
 
"On
 
Hold"
 
status
 
for
 
affected
 
users.
 
Monitoring
 
the
 
system
 
for
 
"On
 
Hold"
 
transitions
 
is
 
a
 
critical
 
DevOps
 
task
 
for
 
maintaining
 
data
 
flow.
7
 
4.
 
Data
 
Granularity
 
and
 
Temporal
 
Structures
 
Understanding
 
the
 
distinction
 
between
 
"Summary"
 
(Daily)
 
data
 
and
 
"Epoch"
 
(Intraday)
 
data
 
is
 
the
 
single
 
most
 
important
 
factor
 
in
 
database
 
schema
 
design.
 
4.1
 
Daily
 
Summaries
 
("Dailies")
 
The
 
dailies
 
endpoint
 
provides
 
a
 
high-level
 
aggregation
 
of
 
a
 
user's
 
24-hour
 
period.
 
It
 
is
 
the
 
"single
 
source
 
of
 
truth"
 
for
 
total
 
volume
 
metrics.
 
●
 
Resolution:
 
One
 
record
 
per
 
user
 
per
 
calendar
 
day.
 
●
 
Key
 
Metrics:
 
Total
 
steps,
 
distance,
 
active
 
calories,
 
resting
 
heart
 
rate,
 
and
 
intensity
 
minutes.
 
●
 
Behavior:
 
The
 
Daily
 
summary
 
is
 
mutable
 
throughout
 
the
 
day.
 
If
 
a
 
user
 
syncs
 
at
 
noon,
 
they
 
might
 
have
 
5,000
 
steps.
 
If
 
they
 
sync
 
again
 
at
 
8
 
PM,
 
the
 
Daily
 
record
 
for
 
that
 
date
 
is
 
updated
 
to
 
10,000
 
steps.
 
Developers
 
must
 
implement
 
"Upsert"
 
(Update
 
or
 
Insert)
 
logic
 
based
 
on
 
the
 
summaryId
 
or
 
calendarDate.
8
 
●
 
Temporal
 
Logic:
 
The
 
field
 
durationInSeconds
 
typically
 
defaults
 
to
 
86400
 
(24
 
hours).
 
However,
 
on
 
the
 
day
 
of
 
device
 
setup
 
or
 
timezone
 
changes,
 
this
 
may
 
vary.
 
4.2
 
Epoch
 
Data
 
(High-Resolution
 
Intraday)
 
Epochs
 
break
 
the
 
day
 
into
 
granular
 
buckets,
 
allowing
 
for
 
circadian
 
rhythm
 
analysis
 
and
 
pattern
 
detection.
 
●
 
Resolution:
 
Typically
 
15-minute
 
intervals
.
 
A
 
full
 
day
 
consists
 
of
 
96
 
epoch
 
records.
 
●
 
Data
 
Content:
 
Each
 
epoch
 
contains
 
the
 
steps,
 
calories,
 
and
 
intensity
 
accumulated
 
only
 
within
 
that
 
15-minute
 
window.
 
It
 
also
 
includes
 
activeTimeInSeconds,
 
which
 
indicates
 
how
 
much
 
of
 
that
 
15-minute
 
window
 
the
 
user
 
was
 
actually
 
moving.
 
●
 
Partial
 
Epochs:
 
If
 
a
 
user
 
syncs
 
at
 
10:07
 
AM,
 
the
 
epoch
 
for
 
the
 
10:00-10:15
 
bucket
 
will
 
be
 

---PAGE---

a
 
"partial"
 
epoch
 
with
 
a
 
duration
 
of
 
420
 
seconds.
 
When
 
the
 
user
 
syncs
 
again
 
after
 
10:15,
 
this
 
record
 
will
 
be
 
replaced
 
by
 
the
 
full
 
900-second
 
epoch.
 
This
 
replacement
 
mechanism
 
requires
 
careful
 
handling
 
in
 
time-series
 
databases
 
to
 
avoid
 
duplicate
 
data
 
summation.
8
 
Table
 
2:
 
Summary
 
vs.
 
Epoch
 
Comparison
 
Feature
 
Daily
 
Summary
 
Epoch
 
Data
 
Granularity
 
24
 
Hours
 
15
 
Minutes
 
Volume
 
1
 
record/day
 
~96
 
records/day
 
Storage
 
Cost
 
Low
 
High
 
Use
 
Case
 
Trends,
 
Gamification,
 
Compliance
 
Pattern
 
Recognition,
 
Sleep
 
Hygiene,
 
Energy
 
Modeling
 
Key
 
ID
 
summaryId
 
+
 
calendarDate
 
summaryId
 
+
 
startTimeInSeconds
 
5.
 
Detailed
 
JSON
 
Data
 
Structures
 
The
 
Garmin
 
Health
 
API
 
returns
 
data
 
in
 
rich
 
JSON
 
objects.
 
Below
 
is
 
a
 
detailed
 
analysis
 
of
 
the
 
schemas
 
for
 
critical
 
health
 
metrics,
 
integrating
 
findings
 
from
 
multiple
 
research
 
snippets
 
to
 
construct
 
a
 
complete
 
picture.
 
5.1
 
The
 
Daily
 
Summary
 
JSON
 
The
 
Daily
 
JSON
 
is
 
the
 
most
 
commonly
 
accessed
 
endpoint.
 
It
 
aggregates
 
data
 
from
 
all
 
devices
 
the
 
user
 
wears.
 
 
JSON
 
 
 
{
 
  
"dailies"
:
 
}
 
 

---PAGE---

Field
 
Analysis:
 
●
 
startTimeOffsetInSeconds:
 
This
 
is
 
critical
 
for
 
normalizing
 
data
 
to
 
UTC.
 
It
 
represents
 
the
 
offset
 
from
 
UTC
 
of
 
the
 
user's
 
location.
 
●
 
consumedCalories:
 
This
 
value
 
is
 
populated
 
only
 
if
 
the
 
user
 
links
 
a
 
nutrition
 
tracking
 
app
 
(like
 
MyFitnessPal)
 
to
 
Garmin
 
Connect.
8
 
●
 
activeTimeInSeconds:
 
This
 
differs
 
from
 
moderateIntensityDuration.
 
A
 
user
 
can
 
be
 
"active"
 
(walking
 
slowly)
 
without
 
triggering
 
"intensity
 
minutes"
 
(which
 
require
 
a
 
specific
 
MET
 
threshold).
8
 
●
 
uncategorizedStressDurationInSeconds:
 
This
 
bucket
 
captures
 
time
 
where
 
stress
 
could
 
not
 
be
 
calculated,
 
often
 
due
 
to
 
physical
 
movement
 
(running)
 
interfering
 
with
 
HRV
 
readings
 
or
 
the
 
device
 
being
 
off-wrist.
 
5.2
 
The
 
Epoch
 
JSON
 
Epochs
 
provide
 
the
 
intra-day
 
narrative.
 
 
JSON
 
 
 
{
 
  
"epochs"
:
 
}
 
 
Field
 
Analysis:
 
●
 
activityType:
 
Can
 
be
 
SEDENTARY,
 
GENERIC
 
(movement
 
detected
 
but
 
not
 
classified),
 
or
 
WALKING
 
(pattern
 
match).
 
This
 
creates
 
a
 
"timeline"
 
of
 
the
 
user's
 
day.
8
 
●
 
met:
 
The
 
Metabolic
 
Equivalent
 
of
 
Task.
 
A
 
value
 
of
 
1.0
 
is
 
resting.
 
Values
 
>
 
3.0
 
denote
 
moderate
 
activity.
 
This
 
is
 
an
 
estimated
 
value
 
based
 
on
 
user
 
biometrics
 
and
 
movement.
 
●
 
meanMotionIntensity:
 
A
 
distinct
 
Garmin
 
metric
 
(scale
 
0-7)
 
derived
 
from
 
the
 
accelerometer.
 
A
 
user
 
fidgeting
 
at
 
a
 
desk
 
might
 
generate
 
steps
 
=
 
0
 
but
 
meanMotionIntensity
 
>
 
0,
 
distinguishing
 
them
 
from
 
a
 
user
 
who
 
is
 
sleeping
 
or
 
not
 
wearing
 
the
 
device.
8
 
5.3
 
Sleep
 
and
 
Sleep
 
Stage
 
Architecture
 
Sleep
 
data
 
is
 
among
 
the
 
most
 
complex
 
due
 
to
 
the
 
segmentation
 
of
 
stages
 
(Light,
 
Deep,
 
REM,
 
Awake)
 
and
 
the
 
validity
 
of
 
the
 
session.
 
 

---PAGE---

JSON
 
 
 
{
 
  
"sleeps"
:,
 
        
"light"
:
 
[...
 
],
 
        
"rem"
:
 
[...
 
],
 
        
"awake"
:
 
[...
 
]
 
      
},
 
      
"validation"
:
 
"AUTO_FINAL"
 
    
}
 
  
]
 
}
 
 
Field
 
Analysis:
 
●
 
validation:
 
This
 
is
 
a
 
crucial
 
data
 
quality
 
flag.
 
○
 
AUTO_TENTATIVE:
 
The
 
user
 
just
 
woke
 
up;
 
the
 
server
 
has
 
done
 
a
 
preliminary
 
pass,
 
but
 
the
 
sleep
 
window
 
might
 
change.
 
○
 
AUTO_FINAL:
 
The
 
algorithms
 
have
 
fully
 
processed
 
the
 
night;
 
this
 
is
 
the
 
definitive
 
record.
 
○
 
MANUAL:
 
The
 
user
 
edited
 
their
 
sleep
 
start/end
 
times
 
in
 
the
 
app.
 
This
 
data
 
is
 
subjective
 
and
 
may
 
be
 
less
 
reliable
 
for
 
physiological
 
study.
8
 
○
 
DEVICE:
 
Data
 
generated
 
solely
 
by
 
the
 
device
 
without
 
server-side
 
post-processing
 
(rare
 
in
 
modern
 
API
 
versions).
 
●
 
sleepLevelsMap:
 
Provides
 
the
 
exact
 
start/end
 
times
 
for
 
every
 
sleep
 
stage
 
transition,
 
enabling
 
the
 
reconstruction
 
of
 
a
 
hypnogram.
 
5.4
 
Heart
 
Rate
 
Variability
 
(HRV)
 
HRV
 
is
 
the
 
gold
 
standard
 
for
 
recovery
 
monitoring.
 
Garmin
 
exposes
 
this
 
primarily
 
through
 
nightly
 
averages
 
and
 
specific
 
5-minute
 
sampling
 
intervals.
 
 
JSON
 
 
 
{
 
  
"hrv"
:
 
}
 
 
Field
 
Analysis:
 

---PAGE---

●
 
lastNightAvg:
 
The
 
RMSST
 
(Root
 
Mean
 
Square
 
of
 
Successive
 
Differences)
 
average
 
for
 
the
 
sleep
 
period,
 
measured
 
in
 
milliseconds.
 
●
 
baseline:
 
Garmin
 
establishes
 
a
 
3-week
 
baseline
 
for
 
each
 
user.
 
This
 
object
 
allows
 
developers
 
to
 
contextualize
 
the
 
current
 
lastNightAvg.
 
If
 
lastNightAvg
 
is
 
below
 
baseline.low,
 
the
 
user
 
is
 
likely
 
fatigued
 
or
 
fighting
 
illness.
 
●
 
hrvValues:
 
A
 
map
 
where
 
the
 
Key
 
is
 
the
 
offset
 
in
 
seconds
 
from
 
the
 
sleep
 
start
 
time,
 
and
 
the
 
Value
 
is
 
the
 
HRV
 
(ms)
 
for
 
that
 
5-minute
 
window.
 
This
 
allows
 
the
 
plotting
 
of
 
HRV
 
trends
 
throughout
 
the
 
night
 
(e.g.,
 
rising
 
HRV
 
indicates
 
physiological
 
recovery).
9
 
6.
 
Rate
 
Limiting
 
and
 
Commercial
 
Limitations
 
The
 
Garmin
 
Health
 
API
 
is
 
not
 
an
 
open,
 
limitless
 
resource.
 
It
 
governs
 
usage
 
through
 
strict
 
rate
 
limiting
 
tiers
 
and
 
commercial
 
licensing
 
models.
 
6.1
 
Evaluation
 
vs.
 
Production
 
Environments
 
●
 
Evaluation
 
Mode:
 
Upon
 
approval,
 
developers
 
receive
 
Evaluation
 
keys.
 
These
 
are
 
throttled.
 
Common
 
limits
 
are
 
historically
 
cited
 
around
 
500
 
requests
 
per
 
day
 
or
 
a
 
limited
 
number
 
of
 
unique
 
users
 
(e.g.,
 
50
 
users).
 
Exceeding
 
this
 
triggers
 
the
 
429
 
Too
 
Many
 
Requests
 
error
 
with
 
a
 
specific
 
message:
 
"Quota
 
limit
 
exceeded.
 
Identifier
 
:
 
[API
 
Key]"
.
10
 
●
 
Production
 
Mode:
 
Moving
 
to
 
production
 
requires
 
a
 
business
 
review.
 
Production
 
keys
 
have
 
significantly
 
higher
 
limits
 
(often
 
tens
 
of
 
thousands
 
of
 
requests
 
per
 
second
 
depending
 
on
 
the
 
negotiated
 
contract)
 
to
 
support
 
enterprise
 
scale.
 
6.2
 
The
 
Backfill
 
Limitation
 
A
 
common
 
pitfall
 
is
 
the
 
90-day
 
backfill
 
limit
.
 
When
 
a
 
new
 
user
 
connects,
 
the
 
partner
 
might
 
want
 
to
 
import
 
their
 
entire
 
history.
 
However,
 
the
 
backfill
 
endpoint
 
restricts
 
a
 
single
 
request
 
to
 
a
 
date
 
range
 
of
 
90
 
days.
 
To
 
fetch
 
3
 
years
 
of
 
history,
 
the
 
developer
 
must
 
implement
 
a
 
loop
 
that
 
issues
 
separate
 
backfill
 
requests
 
for
 
each
 
90-day
 
chunk
 
(e.g.,
 
2023-01-01
 
to
 
2023-03-31,
 
then
 
2023-04-01
 
to
 
2023-06-30).
 
●
 
Asynchronous
 
Nature:
 
Backfill
 
requests
 
do
 
not
 
return
 
data
 
immediately.
 
They
 
trigger
 
the
 
"Push"
 
or
 
"Ping"
 
mechanism.
 
The
 
system
 
will
 
start
 
sending
 
webhooks
 
for
 
the
 
requested
 
historical
 
data
 
as
 
if
 
it
 
were
 
being
 
synced
 
new.
11
 
6.3
 
Commercial
 
Licensing
 
Fees
 
Unlike
 
many
 
social
 
API
 
platforms,
 
the
 
Garmin
 
Health
 
API
 
is
 
a
 
revenue-generating
 
product
 
for
 
Garmin.
 
While
 
access
 
to
 
the
 
Developer
 
Program
 
is
 
free
 
for
 
testing,
 
commercial
 
deployment
 
often
 
incurs
 
a
 
one-time
 
license
 
fee
 
(historically
 
referenced
 
around
 
$5,000,
 
though
 
subject
 
to
 
current
 
contract
 
terms)
 
or
 
requires
 
a
 
minimum
 
hardware
 
purchase
 
commitment.
 
This
 
fee
 
structure
 
acts
 
as
 
a
 
gatekeeper,
 
ensuring
 
that
 
only
 
serious
 
enterprise
 
players
 
utilize
 
the
 

---PAGE---

high-fidelity
 
data
 
streams.
12
 
7.
 
Webhook
 
Implementation:
 
Technical
 
Deep
 
Dive
 
The
 
webhook
 
receiver
 
is
 
the
 
"front
 
door"
 
of
 
the
 
partner's
 
infrastructure.
 
It
 
must
 
be
 
secure,
 
idempotent,
 
and
 
fast.
 
7.1
 
Payload
 
Signatures
 
and
 
Verification
 
Garmin
 
signs
 
every
 
webhook
 
request
 
to
 
ensure
 
authenticity.
 
The
 
signature
 
is
 
usually
 
found
 
in
 
a
 
header
 
(e.g.,
 
Signature
 
or
 
Garmin-Signature).
 
●
 
Mechanism:
 
The
 
signature
 
is
 
an
 
HMAC-SHA1
 
or
 
HMAC-SHA256
 
hash
 
of
 
the
 
request
 
body,
 
generated
 
using
 
the
 
partner's
 
Consumer
 
Secret
 
(Client
 
Secret).
 
●
 
Validation
 
Steps:
 
1.
 
Capture
 
the
 
raw
 
body
 
of
 
the
 
incoming
 
POST
 
request.
 
2.
 
Retrieve
 
your
 
Consumer
 
Secret
 
from
 
your
 
secure
 
vault.
 
3.
 
Compute
 
the
 
hash
 
of
 
the
 
raw
 
body
 
using
 
the
 
secret.
 
4.
 
Compare
 
your
 
computed
 
hash
 
with
 
the
 
value
 
in
 
the
 
header.
 
5.
 
Critical:
 
If
 
they
 
do
 
not
 
match,
 
reject
 
the
 
request
 
with
 
401
 
Unauthorized.
 
This
 
prevents
 
replay
 
attacks
 
and
 
spoofing.
 
7.2
 
Idempotency
 
and
 
Duplication
 
Due
 
to
 
the
 
"at-least-once"
 
delivery
 
guarantee
 
of
 
webhooks
 
and
 
the
 
potential
 
for
 
network
 
retries,
 
a
 
partner
 
might
 
receive
 
the
 
same
 
payload
 
twice.
 
●
 
Handling:
 
Database
 
writes
 
should
 
be
 
idempotent.
 
When
 
inserting
 
a
 
Daily
 
summary,
 
use
 
the
 
summaryId
 
as
 
a
 
unique
 
constraint.
 
If
 
a
 
record
 
with
 
the
 
same
 
summaryId
 
arrives,
 
update
 
the
 
existing
 
record
 
rather
 
than
 
creating
 
a
 
duplicate.
 
This
 
handles
 
the
 
scenario
 
where
 
a
 
partial
 
day
 
is
 
updated
 
to
 
a
 
full
 
day
 
(the
 
summaryId
 
often
 
remains
 
the
 
same
 
or
 
the
 
conflict
 
logic
 
uses
 
the
 
date
 
+
 
userId
 
composite
 
key).
7
 
7.3
 
Notification
 
JSON
 
Example
 
(Ping)
 
When
 
using
 
the
 
Ping
 
architecture,
 
the
 
payload
 
is
 
lightweight:
 
 
JSON
 
 
 
{
 
  
"dailies"
:
 

---PAGE---

}
 
 
Action:
 
The
 
partner
 
server
 
must
 
extract
 
the
 
callbackURL,
 
sign
 
a
 
new
 
GET
 
request
 
using
 
the
 
userAccessToken
 
and
 
their
 
client
 
credentials,
 
and
 
fetch
 
the
 
full
 
data.
 
Note
 
that
 
uploadStartTimeInSeconds
 
refers
 
to
 
when
 
the
 
upload
 
happened
,
 
not
 
the
 
date
 
of
 
the
 
data
 
itself.
11
 
8.
 
Conclusion
 
and
 
Strategic
 
Recommendations
 
The
 
Garmin
 
Health
 
API
 
is
 
a
 
rigorous,
 
industrial-strength
 
interface
 
designed
 
for
 
high-value
 
health
 
applications.
 
Its
 
complexity—manifested
 
in
 
the
 
PKCE
 
auth
 
flow,
 
the
 
Push
 
architecture,
 
and
 
the
 
granular
 
Epoch
 
data
 
structures—is
 
the
 
cost
 
of
 
entry
 
for
 
accessing
 
one
 
of
 
the
 
most
 
reliable
 
biometric
 
datasets
 
in
 
the
 
world.
 
For
 
the
 
Developer:
 
●
 
Adopt
 
Async
 
Thinking:
 
Do
 
not
 
build
 
a
 
system
 
that
 
expects
 
immediate
 
data
 
upon
 
user
 
request.
 
Build
 
a
 
system
 
that
 
reacts
 
to
 
webhooks.
 
●
 
Master
 
Time:
 
Pay
 
close
 
attention
 
to
 
startTimeOffsetInSeconds.
 
Health
 
data
 
without
 
timezone
 
context
 
is
 
scientifically
 
useless.
 
●
 
Respect
 
the
 
Limits:
 
Implement
 
exponential
 
backoff
 
for
 
rate
 
limits
 
and
 
handle
 
the
 
90-day
 
backfill
 
constraints
 
logically.
 
For
 
the
 
Architect:
 
●
 
Plan
 
for
 
Storage:
 
Epoch
 
data
 
grows
 
rapidly.
 
15-minute
 
resolution
 
for
 
10,000
 
users
 
requires
 
a
 
time-series
 
database
 
(e.g.,
 
InfluxDB,
 
TimescaleDB)
 
or
 
a
 
well-partitioned
 
relational
 
store.
 
●
 
Security
 
First:
 
The
 
migration
 
to
 
OAuth
 
2.0
 
PKCE
 
is
 
not
 
optional.
 
Ensure
 
token
 
vaults
 
are
 
secure
 
and
 
rotation
 
logic
 
is
 
atomic.
 
By
 
adhering
 
to
 
these
 
protocols,
 
development
 
teams
 
can
 
leverage
 
the
 
Garmin
 
Health
 
API
 
to
 
build
 
predictive,
 
personalized,
 
and
 
clinical-grade
 
health
 
solutions
 
that
 
stand
 
apart
 
in
 
a
 
crowded
 
digital
 
health
 
marketplace.
 
Alıntılanan
 
çalışmalar
 
1.
 
Health
 
API
 
|
 
Garmin
 
Connect
 
Developer
 
Program,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://developer.garmin.com/gc-developer-program/health-api/
 
2.
 
Overview
 
|
 
Garmin
 
Connect
 
Developer
 
Program,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://developer.garmin.com/gc-developer-program/
 
3.
 
Overview
 
|
 
Health
 
SDKs
 
-
 
Garmin
 
Developers,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://developer.garmin.com/health-sdk/
 
4.
 
Activity
 
API
 
|
 
Garmin
 
Connect
 
Developer
 
Program,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 

---PAGE---

https://developer.garmin.com/gc-developer-program/activity-api/
 
5.
 
Garmin
 
Connect
 
Developer
 
Program
 
OAuth2.0
 
PKCE
 
Specification,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://developerportal.garmin.com/sites/default/files/OAuth2PKCE_1.pdf
 
6.
 
Garmin
 
Connect
 
Developer
 
Program
 
FAQ,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://developer.garmin.com/gc-developer-program/program-faq/
 
7.
 
Garmin
 
Developer
 
Program
 
Activity
 
API
 
|
 
PDF
 
|
 
Boolean
 
Data
 
Type
 
-
 
Scribd,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://www.scribd.com/document/794184899/Garmin-Developer-Program-Activ 
ity-API
 
8.
 
Garmin
 
API
 
-
 
Reference
 
-
 
Avicenna
 
Forum,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://forum.avicennaresearch.com/t/garmin-api/1260
 
9.
 
Garmin
 
HRV
 
Data
 
available
 
from
 
Terra
 
API,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://tryterra.co/blog/garmin-hrv-data-available-from-terra-api-46e8ce2ae9b4
 
10.
 
Error-message
 
:
 
Too
 
many
 
request:
 
Limit
 
per
 
:
 
Rate
 
limit
 
quota
 
violation.
 
-
 
Connect
 
IQ
 
Bug
 
Reports
 
-
 
Garmin
 
Forums,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://forums.garmin.com/developer/connect-iq/i/bug-reports/error-message-to 
o-many-request-limit-per-rate-limit-quota-violation
 
11.
 
Don`t
 
give
 
Daily
 
Summaries
 
from
 
Garmin
 
Api
 
-
 
Stack
 
Overflow,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://stackoverflow.com/questions/48210353/dont-give-daily-summaries-from- 
garmin-api
 
12.
 
Garmin
 
Connect
 
New
 
Policy
 
Impact
 
on
 
ConnectStats
 
and
 
3rd
 
party
 
apps,
 
erişim
 
tarihi
 
Aralık
 
3,
 
2025,
 
https://ro-z.net/blog/garmin/garmin-connect-new-policy-impact-on-connectstat 
s-and-3rd-party-apps/
 

---PAGE---

