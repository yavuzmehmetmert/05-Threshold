"""
AI Planner (Multi-Action Orchestrator)
=======================================

Upgrades from single-intent classification to multi-action planning.
Returns an ExecutionPlan with ordered list of handler actions.

Supports:
- Complex queries requiring multiple handlers
- User input collection for memory
- Sequential execution with result passing
"""

import os
import json
import re
import google.generativeai as genai
from typing import Literal, Optional, Dict, Any, List
from dataclasses import dataclass, field, asdict
from datetime import datetime


# Valid handlers
VALID_HANDLERS = {
    "welcome_intent",
    "small_talk_intent",
    "farewell_intent",
    "sohbet_handler", 
    "db_handler",
    "training_detail_handler",
    "memory_handler"  # New: for saving user inputs
}


@dataclass
class ActionStep:
    """Single action in an execution plan."""
    handler: str                          # Handler to execute
    entities: Dict[str, Any] = field(default_factory=dict)  # Handler params
    requires_input: bool = False          # Needs user response?
    input_prompt: str = ""                # Question for user
    depends_on: int = -1                  # Index of step this depends on (-1 = none)
    
    def to_dict(self) -> dict:
        return asdict(self)


@dataclass
class ExecutionPlan:
    """
    Multi-action execution plan.
    
    Generated by the Planner, executed by the Orchestrator.
    """
    thought_process: str                  # AI reasoning (for debug)
    steps: List[ActionStep] = field(default_factory=list)
    needs_user_input: bool = False        # True if any step requires input
    confidence: float = 0.9               # Overall plan confidence
    
    def to_dict(self) -> dict:
        return {
            "thought_process": self.thought_process,
            "steps": [s.to_dict() for s in self.steps],
            "needs_user_input": self.needs_user_input,
            "confidence": self.confidence
        }
    
    @property
    def is_single_action(self) -> bool:
        return len(self.steps) == 1
    
    @property
    def step_count(self) -> int:
        return len(self.steps)


# Import handler registry for dynamic capabilities
from coach_v2.handler_registry import get_handler_capabilities_prompt, HANDLER_REGISTRY

# Planner prompt - uses dynamic handler capabilities
def get_planner_prompt() -> str:
    """Generate Planner prompt with dynamic handler capabilities."""
    capabilities = get_handler_capabilities_prompt()
    
    # Use regular string with {{}} for format() placeholders
    # JSON examples use literal braces which need {{{{}}}} in format strings
    prompt = '''Sen bir koşu asistanı PLANLAYICISISIN. Kullanıcının isteğini analiz et ve bir YÜRÜTME PLANI oluştur.

{conversation_history}

{metrics_context}

SON MESAJ: "{message}"

# SENİN YETENEKLERİN (Kullanabileceğin Handler'lar)

''' + capabilities + '''

# PLANLAMA KURALLARI

1. Her adım bir öncekinin sonucuna bağlı olabilir (depends_on)
2. Veri çekmeden yorum yapma - önce veri, sonra yorum
3. **LOOKUP PATTERN**: "En sıcak", "en hızlı", "en uzun" gibi sorgular için ÖNCE db_handler ile aktiviteyi bul, SONRA training_detail_handler ile analiz et
4. db_handler iki modda çalışır:
   - **lookup**: Belirli kritere göre aktivite bul (activity_id döndürür)
   - **aggregate**: Toplam/ortalama istatistik çek
5. Son adım genelde sohbet_handler ile özet/tavsiye

# JSON FORMAT

Sadece aşağıdaki JSON formatını döndür, başka bir şey yazma:

```json
{{
  "thought_process": "...",
  "plan": [
    {{"handler": "handler_name", "description": "...", "entities": {{}}, "depends_on": null}}
  ],
  "confidence": 0.9
}}
```

# ÖRNEK 1: "Bugünkü koşum ile bir önceki koşumu karşılaştır"

```json
{{
  "thought_process": "Karşılaştırma için iki aktivitenin detaylı verisini çekmeliyim. Sonra analiz edip yorumlamalıyım.",
  "plan": [
    {{"handler": "training_detail_handler", "description": "Bugünkü koşunun detaylarını çek", "entities": {{"activity_ref": "today"}}, "depends_on": null}},
    {{"handler": "training_detail_handler", "description": "Önceki koşu detaylarını çek", "entities": {{"activity_ref": "previous"}}, "depends_on": null}},
    {{"handler": "sohbet_handler", "description": "İki koşuyu karşılaştır ve analiz et", "entities": {{}}, "depends_on": [1, 2]}}
  ],
  "confidence": 0.95
}}
```

# ÖRNEK 2: "En sıcak havadaki koşuyu analiz et" (LOOKUP PATTERN)

```json
{{
  "thought_process": "Önce veritabanından en yüksek sıcaklıktaki aktiviteyi bulmalıyım. Sonra o aktivitenin detaylarını çekip analiz etmeliyim.",
  "plan": [
    {{"handler": "db_handler", "description": "En sıcak hava koşullarındaki aktiviteyi bul", "entities": {{"query_type": "lookup", "lookup_criteria": "hottest", "order_by": "weather_temp DESC"}}, "depends_on": null}},
    {{"handler": "training_detail_handler", "description": "Bulunan aktiviteyi analiz et", "entities": {{"use_previous_activity": true}}, "depends_on": [1]}},
    {{"handler": "sohbet_handler", "description": "Sıcak hava koşullarında performansı yorumla", "entities": {{}}, "depends_on": [2]}}
  ],
  "confidence": 0.90
}}
```

# ÖRNEK 3: "En hızlı koşum hangisi?" (LOOKUP PATTERN)

```json
{{
  "thought_process": "En hızlı koşu = en düşük pace veya en yüksek ortalama hız. Önce bu aktiviteyi bulup sonra analiz etmeliyim.",
  "plan": [
    {{"handler": "db_handler", "description": "En hızlı koşuyu bul", "entities": {{"query_type": "lookup", "lookup_criteria": "fastest", "order_by": "avg_speed DESC"}}, "depends_on": null}},
    {{"handler": "training_detail_handler", "description": "Bulunan aktiviteyi analiz et", "entities": {{"use_previous_activity": true}}, "depends_on": [1]}},
    {{"handler": "sohbet_handler", "description": "Performansı yorumla", "entities": {{}}, "depends_on": [2]}}
  ],
  "confidence": 0.90
}}
```

# ÖRNEK 4: "Bu hafta kaç km koştum?" (AGGREGATE)

```json
{{
  "thought_process": "Haftalık toplam mesafe istatistiği isteniyor. db_handler ile aggregate çekmeliyim.",
  "plan": [
    {{"handler": "db_handler", "description": "Bu haftaki toplam mesafeyi hesapla", "entities": {{"query_type": "aggregate", "period": "this_week", "metric": "total_distance"}}, "depends_on": null}},
    {{"handler": "sohbet_handler", "description": "Sonucu açıkla", "entities": {{}}, "depends_on": [1]}}
  ],
  "confidence": 0.95
}}
```

# ÖNEMLİ: LOOKUP KRİTERLERİ

- **hottest**: En sıcak hava (weather_temp DESC)
- **coldest**: En soğuk hava (weather_temp ASC)
- **fastest**: En hızlı (avg_speed DESC veya duration/distance ASC)
- **slowest**: En yavaş (avg_speed ASC)
- **longest**: En uzun mesafe (distance DESC)
- **shortest**: En kısa mesafe (distance ASC)
- **hardest**: En zor (training_effect DESC veya elevation_gain DESC)
- **highest_hr**: En yüksek nabız (max_hr DESC)
- **best**: En iyi koşu (training_effect DESC, vo2_max DESC gibi composite)
- **year_best**: Belirli yılın en iyi koşusu (EXTRACT(YEAR) filtresi ile)

# ÖRNEK 5: "2024'teki en iyi koşum hangisi?" (YEAR FILTER + LOOKUP)

```json
{{{{
  "thought_process": "Kullanıcı 2024 yılındaki en iyi koşuyu soruyor. Önce db_handler ile 2024 yılındaki koşuları filtreleyip en iyi performansı bulmalıyım. 'koşum' kelimesi olduğu için activity_type running olmalı. training_effect veya vo2_max'a göre sıralayıp bulmam lazım.",
  "plan": [
    {{{{"handler": "db_handler", "description": "2024 yılındaki en iyi koşuyu bul", "entities": {{{{"query_type": "lookup", "lookup_criteria": "year_best", "description": "2024 yılındaki en yüksek training_effect'e sahip koşuyu bul"}}}}, "depends_on": null}}}},
    {{{{"handler": "training_detail_handler", "description": "Bulunan aktiviteyi detaylı analiz et", "entities": {{{{"use_previous_activity": true}}}}, "depends_on": [1]}}}},
    {{{{"handler": "sohbet_handler", "description": "Neden bu koşunun en iyi olduğunu açıkla", "entities": {{{{}}}}, "depends_on": [2]}}}}
  ],
  "confidence": 0.90
}}}}
```

JSON:'''
    
    return prompt


# Keep old prompt as fallback (will be replaced by dynamic version)
PLANNER_PROMPT = get_planner_prompt()


def get_api_key_from_db():
    """Get API key from database for user 1."""
    try:
        from database import SessionLocal
        from coach.crypto import decrypt_api_key
        import models
        
        db = SessionLocal()
        user = db.query(models.User).filter(models.User.id == 1).first()
        if user and user.gemini_api_key_encrypted:
            api_key = decrypt_api_key(user.gemini_api_key_encrypted, user.gemini_api_key_iv or b'')
            db.close()
            return api_key
        db.close()
    except Exception as e:
        print(f"Failed to get API key from DB: {e}")
    return None


class Planner:
    """
    AI Planner for multi-action orchestration.
    
    Analyzes user queries and returns an ExecutionPlan with
    ordered list of handler actions.
    """
    
    def __init__(self, api_key: str = None):
        self.api_key = api_key or get_api_key_from_db() or os.getenv("GOOGLE_API_KEY")
        if self.api_key:
            genai.configure(api_key=self.api_key)
            # Use Gemini 3 Pro for complex plan reasoning
            # We will use system_instruction in create_plan to avoid safety blocks
            self.model_name = "gemini-3-pro-preview"
        else:
            self.model_name = None
    
    def create_plan(
        self, 
        message: str, 
        conversation_history: str = "",
        metrics_context: str = "",
        return_debug: bool = False
    ) -> ExecutionPlan:
        """
        Create an execution plan for the user message.
        
        Args:
            message: User's message
            conversation_history: Formatted history for context
            metrics_context: User metrics (TSB, etc.)
            return_debug: If True, return (ExecutionPlan, debug_dict)
            
        Returns:
            ExecutionPlan or tuple (ExecutionPlan, debug_dict)
        """
        debug_info = {
            "model": "gemini-2.0-flash",
            "prompt": None,
            "raw_response": None,
            "parsed_plan": None
        }
        
        if not self.model_name:
            plan = self._fallback_plan(message)
            debug_info["model"] = "fallback_regex"
            debug_info["parsed_plan"] = plan.to_dict()
            return (plan, debug_info) if return_debug else plan
        
        try:
            prompt_main = PLANNER_PROMPT.format(
                message=message,
                conversation_history=conversation_history or "Yeni konuşma",
                metrics_context=metrics_context or ""
            )
            
            # Use Gemini 3 with system_instruction for better safety bypass
            model = genai.GenerativeModel(
                model_name=self.model_name,
                system_instruction=prompt_main
            )
            
            # BLOCK_NONE to be as flexible as possible
            safety_settings = [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
            ]
            
            response = model.generate_content(
                f"SON MESAJ: \"{message}\"\n\nLütfen sadece JSON formatında yürütme planını oluştur.",
                generation_config=genai.GenerationConfig(
                    max_output_tokens=1000,
                    temperature=0.1,
                ),
                safety_settings=safety_settings
            )
            
            # Handle empty/blocked response
            if not response.candidates or not response.candidates[0].content.parts:
                finish_reason = response.candidates[0].finish_reason if response.candidates else "UNKNOWN"
                debug_info["error"] = f"Planner blocked: {finish_reason}"
                plan = self._fallback_plan(message)
                return (plan, debug_info) if return_debug else plan
                
            raw_response = response.text.strip()
            debug_info["model"] = self.model_name
            debug_info["raw_response"] = raw_response
            
            # Parse JSON response
            plan = self._parse_plan_response(raw_response)
            debug_info["parsed_plan"] = plan.to_dict()
            
            return (plan, debug_info) if return_debug else plan
            
        except Exception as e:
            debug_info["error"] = str(e)
            plan = self._fallback_plan(message)
            debug_info["model"] = "fallback_regex"
            debug_info["parsed_plan"] = plan.to_dict()
            return (plan, debug_info) if return_debug else plan
    
    def _parse_plan_response(self, raw_response: str) -> ExecutionPlan:
        """Parse JSON from LLM response into ExecutionPlan."""
        try:
            # Extract JSON from markdown code block
            json_match = re.search(r'```json\s*(.*?)\s*```', raw_response, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                json_str = raw_response
            
            json_str = json_str.strip()
            if json_str.startswith('{') and json_str.endswith('}'):
                data = json.loads(json_str)
                
                thought_process = data.get("thought_process", "")
                confidence = float(data.get("confidence", 0.9))
                
                steps = []
                needs_user_input = False
                
                for item in data.get("plan", []):
                    handler = item.get("handler", "sohbet_handler")
                    if handler not in VALID_HANDLERS:
                        handler = "sohbet_handler"
                    
                    # Handle both old (requires_input) and new (requires_user_input) field names
                    requires_input = item.get("requires_user_input", item.get("requires_input", False))
                    if requires_input:
                        needs_user_input = True
                    
                    # Handle both old (input_prompt) and new (input_question) field names  
                    input_prompt = item.get("input_question", item.get("input_prompt", ""))
                    
                    # Get description if provided
                    description = item.get("description", "")
                    
                    # Get depends_on if provided
                    depends_on = item.get("depends_on", -1)
                    
                    step = ActionStep(
                        handler=handler,
                        entities=item.get("entities", {}),
                        requires_input=requires_input,
                        input_prompt=input_prompt,
                        depends_on=depends_on if isinstance(depends_on, int) else -1
                    )
                    # Store description in entities for debug output
                    if description:
                        step.entities['description'] = description
                    steps.append(step)
                
                if not steps:
                    steps = [ActionStep(handler="sohbet_handler")]
                
                return ExecutionPlan(
                    thought_process=thought_process,
                    steps=steps,
                    needs_user_input=needs_user_input,
                    confidence=confidence
                )
                
        except (json.JSONDecodeError, ValueError) as e:
            pass
        
        # Fallback: try to extract handler name
        for handler in VALID_HANDLERS:
            if handler in raw_response.lower():
                return ExecutionPlan(
                    thought_process="Fallback: extracted single handler",
                    steps=[ActionStep(handler=handler)],
                    confidence=0.6
                )
        
        return ExecutionPlan(
            thought_process="Fallback: default sohbet",
            steps=[ActionStep(handler="sohbet_handler")],
            confidence=0.5
        )
    
    def _fallback_plan(self, message: str) -> ExecutionPlan:
        """Simple regex fallback if API fails."""
        msg = message.lower().strip()
        
        # Greetings
        if any(g in msg for g in ["selam", "merhaba", "hey", "iyi günler"]):
            return ExecutionPlan(
                thought_process="Selamlama algılandı",
                steps=[ActionStep(handler="welcome_intent")],
                confidence=0.95
            )
        
        # Small talk
        if any(s in msg for s in ["nasılsın", "naber", "ne haber"]):
            return ExecutionPlan(
                thought_process="Hal hatır",
                steps=[ActionStep(handler="small_talk_intent")],
                confidence=0.95
            )
        
        # Farewell
        if any(f in msg for f in ["hoşçakal", "görüşürüz", "bye"]):
            return ExecutionPlan(
                thought_process="Vedalaşma",
                steps=[ActionStep(handler="farewell_intent")],
                confidence=0.95
            )
        
        # Training detail
        if any(t in msg for t in ["son koşu", "antrenman", "analiz", "koşumu", "dünkü"]):
            return ExecutionPlan(
                thought_process="Antrenman analizi isteniyor",
                steps=[ActionStep(
                    handler="training_detail_handler",
                    entities={"activity_ref": "last"}
                )],
                confidence=0.9
            )
        
        # DB queries
        if any(d in msg for d in ["kaç km", "toplam", "ortalama", "trend", "hafta", "ay"]):
            return ExecutionPlan(
                thought_process="Veritabanı sorgusu",
                steps=[ActionStep(
                    handler="db_handler",
                    entities={"date": "last_week" if "hafta" in msg else ""}
                )],
                confidence=0.9
            )
        
        # Complex: mentions "and" / "ve" with advice
        if " ve " in msg and any(w in msg for w in ["tavsiye", "yapmalı", "yarın"]):
            return ExecutionPlan(
                thought_process="Karmaşık sorgu: veri + tavsiye",
                steps=[
                    ActionStep(handler="db_handler", entities={}),
                    ActionStep(handler="sohbet_handler", entities={"context": "advice"})
                ],
                confidence=0.8
            )
        
        # Default
        return ExecutionPlan(
            thought_process="Genel sohbet",
            steps=[ActionStep(handler="sohbet_handler")],
            confidence=0.7
        )


# Singleton instance
_planner = None

def get_planner() -> Planner:
    """Get or create the global planner instance."""
    global _planner
    if _planner is None:
        _planner = Planner()
    return _planner


def create_execution_plan(
    message: str, 
    conversation_history: str = "",
    metrics_context: str = ""
) -> ExecutionPlan:
    """Convenience function for creating execution plan."""
    return get_planner().create_plan(message, conversation_history, metrics_context)


def create_execution_plan_with_debug(
    message: str, 
    conversation_history: str = "",
    metrics_context: str = ""
):
    """Create plan with debug info. Returns (ExecutionPlan, debug_dict)."""
    return get_planner().create_plan(
        message, conversation_history, metrics_context, return_debug=True
    )
